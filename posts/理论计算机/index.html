<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=49441&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>理论计算机 | Jiajun, Shen</title>
<meta name="keywords" content="CS">
<meta name="description" content="确定性有穷自动机
状态图 ：状态 ：起始状态(StartState)、接受状态(AcceptState)；转移：输入符号，从一个状态转移到另一个状态； 输出：接受或拒绝。
$M={Q,\Sigma,\delta,q_o,F}$ 字母代表状态集、字母表、转一函数、起始状态、接收状态集
正则语言

语言(Language) ：某个给定字母表上的串(String)的可数集合
如果一个语言被一台有穷自动机识别，则称它是正则语言(Regular Language)
正则运算：并、连接、星号
封闭性 ：正则运算、补、交
并的构造：新初始状态通过两个$\varepsilon$移动到两个自动机的起始状态
连接的构造：将第一个自动机的接受状态通过$\varepsilon$移动连接到第二个的初始状态
星号的构造：起始状态是一个接受状态，将新的起始状态和原来的接受状态用$\varepsilon$移动连到原来的起始状态

非确定型有穷自动机

给定当前状态，下一个状态可以不确定，可以包含$\varepsilon$移动，下一个状态可以并行选择
计算规则：移动产生备份，无法移动时，备份消失，有一个备份接受，整个计算就接受
$N={Q,\Sigma,\delta,q_o,F}$，转移函数$\delta:Q\times \Sigma_\varepsilon \rightarrow P(Q)$
$\varepsilon$-NFA：带有$\varepsilon$移动的NFA，可以转化为不含$\varepsilon$移动的NFA
$\varepsilon$-闭包：对每个状态经过$\varepsilon$移动可以到达的集合
修改状态转移表

NFA和DFA的等价性

每台NFA都有等价的DFA
NFA状态的幂集作为DFA的状态集，确定转移函数，去除冗余状态

正则表达式

R是正则表达式，如果R是$a,\varepsilon,\varnothing,(R_1&#43;R_2),(R_1R_2),R_1^*$
正则表达式表达的语言为$L(R)$
如果一个语言可以用正则表达式描述，那么它是正则的
正则表达式转化为NFA：使用并、连接和星号的NFA构造即可
如果一个语言是正则的，则可以用正则表达式描述它
GNFA （广义非确定型有穷自动机，转移箭头可以用任何正则表达式作为标号）转化为正则表达式
任意挑选一个状态$q_{rip}$删去，修改每一个留下来的箭头上标记的正则表达式，得到更短的GNFA，直到最后。
$q_i$到$q_{rip}$有箭头$R_1$,$q_{rip}$到自己有箭头$R_2$，从$q_{rip}$到$q_j$有$R_3$，从$q_i$到$q_j$有$R_4$，则$q_i$到$q_j$的箭头为$(R_1)(R_2)^*(R_3)\cup(R_4)$
算数定律：
并的交换和结合律，单位元是$\varnothing$
连接的结合律（不满足交换），单位元是$\varepsilon$，零元是$\varnothing$
连接对并有左右分配律
交、并的幂等率$L&#43;L=L$，$L\cap L=L$
闭包运算律：$(L^\star)^\star =L^\star $, $\varnothing^\star=\varepsilon$，$\varepsilon ^\star=\varepsilon$，$L^&#43;=LL^*=L^*L$，$L^\star = L^&#43; &#43; \varepsilon$
Arden引理 ：
$P$和$Q$是两个正则表达式，那么方 程$X=Q&#43;XP$存在解$X=QP^*$。进一步地，如果$\varepsilon \notin L(P)$，则方程的解唯一
变量替换法化简正则表达式

泵引理

设$𝐴$是一个正则语言，则存在一个常数$𝑝$ (称为泵长度)，使得若$𝑠 ∈ 𝐴$且 $𝑠 ≥ 𝑝$，则$𝑠$可以被分成3段，𝑠 = 𝑥𝑦𝑧，并且满足下述条件：$∀𝑖 ≥ 0,𝑥𝑦^𝑖𝑧 ∈ 𝐴$, $|𝑦| &gt;0$, $|𝑥𝑦| ≤𝑝$
如果𝑝是语言𝐿的泵长度，则任意𝑝′ ≥ 𝑝也是语言 𝐿的泵长度。语言𝐿的最小泵长度是𝐿的泵长度的最小值
证明语言B不是正则的：精心选取字符串，根据泵引理证明无法抽取
泵引理仅仅是必要条件，满足泵引理不一定是正则语言

迈希尔-尼罗德定理

语言$𝐴$是正则的，当且仅当$≡_A$ 的等价类数目是有限的。如果$≡_A$ 将$Σ^∗$划分为$𝑛$个等价类，则识别$𝐴$的极小DFA恰好有$𝑛$个状态。
证明不是正则语言：证明有无穷个状态是可以区分的

极小化DFA

存在串$x$，使得两个状态一个到达接受，一个到达非接受，则这个串就去区分了两个状态，
存在串区分两个状态，这两个状态是可区分的，否则不可区分，不可区分的状态等价（死状态全部等价）
根据x长度可以区分$n$-等价，$n$-等价的状态不一定是不可区分的
等价状态划分
去掉不可达状态
逐个使用$0$-等价、$1$-等价……不停划分所有状态，直到不变，然后取代表元进行重建
填表法 ：
绘制表格，只要下半部分，去掉对角线以及右上部分
标记$(P,Q)$，其中$P \in F$, $Q\notin F$
迭代标记其他状态对（如果对一个输入产生的对已被标记，则进行标记）
合并等价状态，利用传递性合成

判断DFA等价性

检查两个状态是否同时为中间状态或终止状态，如果不是则不等价。
从两个初始状态开始对于所有的输入，如果出现新的状态对，继续分析，直到没有新的状态对，并且所有状态对都是同时为中间状态或终止状态

带输出的有穷自动机

米利机
输出是状态和输入的函数，输出不仅和当前状态有关，且和输入有关
$M={Q,\Sigma,\delta,\lambda,q_o,F}$, $\lambda: \Sigma\times Q\rightarrow \Delta$输出函数
米利机没有接受状态，不是一个语言识别器
在DFA的转移表的每一个输入中的新状态列后增加输出列
摩尔机
输出是状态的函数
在DFA的转移表后增加输出列
米利机和摩尔机的相互转化
摩尔机转化为米利机：新的输出函数$\lambda&rsquo;( q,a)=\lambda(\delta(q,a))$
米利机转化为摩尔机：

写出米利机对应的状态转移表
将被指向的状态中有不同输出的状态进行切分



文法

概述
文法(Grammar)$𝐺$是一个四元组$𝐺 = (V,T,P,S)$，$V、T、P、S$分别表示语法变量（非终极符号、语法范畴）、终极符、产生式、开始符号。产生式：左部、右部、候选式
直接推导：$γαδ$=&gt;$_Gγβδ$，称$γβδ$在文法$G$中直接归约成$γαδ$
=&gt;$_G$、=&gt;$_G^&#43;$、=&gt;$_G^*$、=&gt;$_G^n$
语法范畴代表的集合：语法变量能推出来的式子
文法的构造、文法的等价
正则文法
文法$G$叫做0型文法（短语结构文法）
1型文法：如果对于$\forall α→β∈P$，均有$|β|≥|α|$成立（上下文有关文法）
2型文法：如果对于$\forall α→β∈P$，均有$|β|≥|α|$成立，并且$α∈V$（上下文无关文法）
3型文法：如果对于$\forall α→β∈P$，具有形式$A→w$,$A→wB$-&gt;正则语言
线性文法：如果对于$\forall α→β∈P$，具有形式$A→w$,$A→wBx$
左线性文法：如果对于$\forall α→β∈P$，具有形式$A→w$,$A→Bw$
左/右线性文法产生的是正则语言，但是混用产生的不是正则文法。
空语句
约定：对于$G$中的任何变量$A$，在需 要的时候，可以出现形如$A→ε$的产生式。

上下文无关文法

产生式$P$具有如下形式：$𝐴 → 𝑥$， 其中，$𝐴∈𝑉$且$𝑥∈ (𝑉∪𝑇)^*$
派生树
派生树$T$的所有叶子顶点从左到右依次标记为$X_1，X_2，&hellip;，X_n$，则称符号串$X_1X_2&hellip;X_n$是$T$的结果
句型$α$的派生树：$G$的结果为$α$的派生树
$S$=&gt;$^*α$的充分必要条件为$G$有一棵结果为$α$的派生树
最左派生(leftmost derivation)：$α$的派生过程中，每一步都是对当前句型的最左变量进行替换。左句型(left sentencial form)：最左派生得到的句型可叫做左句型。最右归约(rightmost reduction)：与最左派生对相的归约叫做最有归约。
最右派生=规范派生
如果$α$是$CFG$ $G$的一个句型，则G中存在$α$的最左派生和最右派生
如果$α$是$CFG$ $G$的一个句型，$α$的派生树与最左派生和最右派生是一 一对应的，但是， 这棵派生树可以对应多个不同的派生
二义性
$CFG$ $G=(V,T,P,S)$，如果存在$w∈L(G)$，$w$至少有两棵不同的派生树，则称$G$是二义性的。否则，$G$为非二义性的
消除二义性：规定运算的优先级/修改或重新设计文法
二义性的问题是不可解的(unsolvable)问题
如果语言$𝐿$不存在非二义性文法，则称$𝐿$是固有二义性的(inherent ambiguity)
解析
穷举搜索解析：利用所有产生式进行一步派生，验证是否匹配。自顶向下的解析、自底向上的解析。
计算效率低，对于$𝑤\notin𝐿(𝐺)$，上述过程可能永不终止。-&gt;去除空产生式和单一产生式
简单文法或𝒔-文法(s-grammar)： 如果它的所有产生式具有如下形式：$𝐴 → 𝑎𝑥$,
其中$𝐴 ∈ 𝑉$,$𝑎 ∈ 𝑇,𝑥 ∈ 𝑉^∗$, 且$(𝐴,𝑎)$在产生式$𝑃$中至多 出现一次。

若$𝐺$是$s$-文法，则对于$∀𝑤 ∈ 𝐿(𝐺)$，$𝑤$的解析复杂度正比于$|𝑤|$。


化简
去除空产生式

首先利用如下算法找到$G$中所有可空变量构成的集合

对所有空产生式$𝐴 → 𝜀$，将$𝐴$放入$𝑉$
对所有如下产生式:$𝐵 → 𝐴_1𝐴_2 ⋯ 𝐴_𝑛$，其中$𝐴_𝑖 ∈ 𝑉 (1≤𝑖≤𝑛)$，将$𝐵$放入$𝑉 $中
重复第二步，直到没有变量可以加入$𝑉$为止


考查$𝑃$中所有如下形式的产生式($A\rightarrow x,1\le|x|$)：将该产生式以及其中可空变量替换成$𝜀$后得到的所有产生式加入$𝑃$


去除单一产生式

构造一个依赖图，边表示单一产生式
非单一产生式保留到$\hat{P}$，对于$A$=&gt;$^*B$的变元，加入$A$-&gt;$y_1|..|y_n$，y_1|..|y_n是$\hat{P}$中$B$在左端的所有产生式的候选式


去除无用产生式

$𝐴$是有用的当且仅当$𝐴$出现在至少一个字符串的派生中
去除无法派生字符串的符号、去除起始变元不可达的符号


范式
乔姆斯基范式

如果$CFG$ $𝐺 = (𝑉, 𝑇, 𝑃, 𝑆)$中的所有产生式 都具有形式：$A → 𝐵𝐶$ ,$𝐴→𝑎$，其中，$𝐴, 𝐵, 𝐶 ∈ 𝑉, 𝑎 ∈ 𝑇$，称$𝐺$为乔姆斯基范式文法
转化：对于过长的产生式引入新变量拆解


格雷巴赫范式

如果$CFG$ $𝐺 = (𝑉, 𝑇, 𝑃, 𝑆)$中的所有产生式都具有形式：$𝐴 → 𝑎𝑥$，其中$𝐴 ∈ 𝑉, 𝑎 ∈ 𝑇, x ∈ V^∗$
CYK算法

$V_{ii}$是所有能产生字符串第$i$位的变量集合
$V_{ij}=\cup {A:A\rightarrow BC, B\in V_{ik},C \in V_{k&#43;1,j}}$





下推自动机

下推自动机𝑀是一个七元组：$M={Q,\Sigma,\Gamma, \delta,q_o,Z_0,F}$，$𝑍_0 ∈ Γ$称为开始符号(start symbol)，是𝑀启动 的时候栈内唯一的一个符号。习惯上又称为栈底符号，$\Gamma$是栈符号表(stack alphabet)。$∀𝐴 ∈ Γ$称作一个栈符号，状态转移函数$\delta:Q\times \Sigma\cup {\varepsilon}×Γ→2^{𝑄×Γ^∗}$
PDA的图形表示：$𝑎,𝑏→𝑐$表示机器从输入中读取$𝑎$时可以用$𝑐$替换栈顶
的符号$𝑏$，$𝑏 → 𝑐$读作: pop b, push c；$𝑎,𝑏,𝑐$中任何一个都可以是$\varepsilon$
PDA的即时描述：$\forall q,w,\gamma∈(𝑄,Σ^∗,Γ^∗)$称为$𝑀$的一个即时描述，$𝑤$是当前还未处理的输入字符串，$𝑀$正注视着$𝑤$的首字符；$𝛾$是堆栈中的符号，习惯上，$𝛾$的最左符号为栈顶符号，最右符号为栈底符号
以终结状态方式接受、以空栈方式接受，两种方法是等价的
下推自动机可以识别上下文无关语言
对于给定的上下文无关语言$L$，存在一个PDA $M$使得$L=L(M)$

包含$\delta(q_0,\varepsilon,z)={(q_1,Sz)}$，压入起始符号
对格雷巴赫范式产生式$A\rightarrow au$存在转移$(q_1,u)\in \delta(q_1,a,A)$
$\delta(q_1,\varepsilon,z)={(q_f,z)}$进入接受状态


如果一个语言被PDA识别，则该语言一定是上下文无关语言

构造（假设PDA一次只能pop或者push一个）

变元集${A_{pq}|p,q\in Q}$；起始变元$A_{q_0,q_{accept}}$
如果$\delta(p,a,\varepsilon)$包含$(r,u)$且$\delta(s,b,u)$包含$(q,\varepsilon)$，产生式加入$A_{pq}\rightarrow A_{pr}aA_{rs}b$
产生式加入$A_{pq}\rightarrow A_{pr}A_{rq}$
加入$A_{pp}\rightarrow \varepsilon$


$A_{pq}$产生$x$，当且仅当$x$把$M$从状态$p$和空栈一起带到状态$q$和空栈


CFL的 泵引理
设A是上下文无关语言, 则存在常数$𝑝$(泵长度)使得,若$𝑠∈𝐴$且$𝑠 ≥𝑝$,则 $𝑠 = 𝑢𝑣𝑥𝑦𝑧$且$\forall i \ge 0,uv^ixy^iz\in A$;$|vy|&gt;0$;$|vxy|\le p$
CFL的 封闭性
并、连接以及星号运算封闭，在交、补运算下不封闭
CFL与RL的交是CFL
$𝐿$是否为空的判定：算法去除文法中无用符号和无用产生式，如果起始变元$𝑆$是无用的，则$𝐿(𝐺)$是空集
$𝐿$是否有穷的判定
可派生性图表示

确定型下推自动机

每次移动仅有至多一种选择，确定型上下文无关语言可以进行高效的解析
对应的语言是$𝐿$被称为确定型上下文无关语言
DPDA与PDA不等价
如果一个文法，根据当前的输入符号以及随后的 𝑘 − 1个输入符号，可以唯一的确定下一步派生所需的产生式，则称该文法是𝐿𝐿(𝑘)文法

图灵机

等价于短语结构文法
TM $𝑀 = (𝑄, \Sigma, \Gamma, \delta, q_0, q_{acc}, q_{rej})$
格局表示为$uqav$；当前状态$𝑞$；当前带内容$uav$；当前扫描符号$a$
判定器：所有输入都停机的图灵机，它们永不循环，称这种图灵机为判定器
图灵可识别：接受、拒绝或不停机；图灵可判定：处处停机
变形
多带图灵机
多维图灵机
非确定性图灵机
枚举器（图灵可识别&lt;=&gt;存在枚举器枚举）

形式语言与自动机

线性有界自动机LBA是一种受限的图灵机，不允许其读写头离开包含输入的带子区域
线性有界自动机等价上下文有关文法

算法

图灵机算法的描述方式
形式化描述

七元组。对图灵机最低层次、最详细程度的描述


实现描述

用日常语言描述图灵机的运行(如何存放数据,如何移动读写头)
不给出状态和转移函数的细节


高层次描述

用日常语言描述算法
不考虑对读写头和带的管理



通用图灵机

存放图灵机的编码、存放图灵机带子的内容、存放图灵机的内部状态
所有图灵机构成的集合是一个可数集

可判定语言

如果存在一个处处停机的图灵机，能够判定给定 的字符串是否属于该语言
与正则语言相关的可判定性问题
DFA接受问题：一个有穷自动机是否接受一个串 ✅
NFA接受问题 ✅
正则表达式派生问题 ✅
DFA空性问题：一个DFA是否根本不接受任何串? ✅
DFA等价性问题：检查两个DFA是否识别同一个语言 ✅

正则语言对对称差封闭


CFG 接受性和空性 ✅

不可判定语言

检查一个图灵机是否接受一个给定的串 ❌ (但是可识别)
存在不能被任何图灵机识别的语言（语言集合不可数）
可判定&lt;=&gt;语言和它的补都可识别，可以推出$\bar{A_{TM}}$不可识别
CFG等价性 ❌
TM空性 ❌
修改图灵机，拒绝w以外的所有输入，在w上模拟原图灵机
然后判定是否为空，得到A_{TM}可判定，矛盾
等价性（检查两个给定的图灵机是否识别相同的语言）❌
从空性开始规约
停机问题HALT_{TM} ❌
正则性（检查给定图灵机有没有等价的有穷自动机） ❌
假设能够判定，构造M_{2}在输入x上，接受$0^n1^n$，其他串模拟M
在输入M_{2}运行R，R接受则接受，拒绝则拒绝
M_{2}自动接受${0^n1^n|n \ge 0}$中的所有串，如果M_{2}接受w, M_{2}就接受所有其他串
波斯特对应问题 ❌

映射可规约

设$A$和$𝐵$是语言，如果存在可计算函数 $𝑓:Σ^∗ →Σ^∗$，使得对于每个$𝑥$，$𝑥∈𝐴$⟺$𝑓 (𝑥) ∈ 𝐵$, 则称语言$A$映射可归约到语言$𝐵$, 记作$𝐴 ≤_𝑚 𝐵$. 称函数$𝑓$为从$A$到$B$的归约，记作$𝐴 ≤_𝑚 𝐵$ via $𝑓$
如果$𝐴 ≤_𝑚 𝐵$且$𝐵$是可判定的，则$𝐴$也是可判定的。可判定语言类在映射可归约下封闭（逆否：如果𝐴 ≤𝑚 𝐵且A是不可判定的，则B也 是不可判定的）
映射归约具有传递性，即: 若$𝐴≤_𝑚𝐵$,且𝐵$≤_𝑚 𝐶$,则$𝐴≤_𝑚 𝐶$
若$𝐴 ≤_𝑚 𝐵$, 且$𝐵$是图灵可识别的$，则$A$也是图灵可识别的
为证$𝐵$不是图灵可识别的，可以证明$𝐴 ≤_m \bar{𝐵}$

时间复杂性

时间复杂度是一个函数：$𝑓(𝑛)$是M在所有长度为$𝑛$的输入上运行时所经过的最大步数
渐进分析方法、渐进上界
大O($\le$)和小o($&lt;$)记法
时间复杂性类：令$𝑡: 𝑁 → 𝑅^&#43;$是一个函数。 TIME$(𝑡(n))$为由$𝑂 (𝑡(𝑛))$ 时间的图灵机判定的所有语言的集合
单带图灵机在$𝑜(𝑛\log 𝑛)$时间内判定的语言都是正则语言。
注意：在==可计算理论==中，丘奇-图灵论题断言：所有合理的计算模型都是等价的，即他们所判定的语言类都是相同的；在==复杂性理论==中，模型的选择影响语言的时间复杂度
设$𝑡(𝑛)$是一个函数，$𝑡 (𝑛) ≥ 𝑛$。则每一个$𝑡(𝑛)$时间的多带图灵机都和某一个$𝑂(𝑡^2(𝑛))$ 时间的单带图灵机等价
设$𝑡(𝑛)$是一个函数，且$𝑡 (𝑛) ≥ 𝑛$。 则每一个$𝑡(𝑛)$时间的非确定型单带图灵机都与某一个$2^{𝑂(𝑡(𝑛))}$ 时间的确定型单带图灵机等价

P类与NP类
P类

能在多项式时间内可判定的语言类
稳健：对于所有和确定型单带图灵机多项式等价的计算模型来说，P是不变的
实用：P大致对应于在计算机上实际可解的(tractable)那一类问题

NP类

NP是非确定型单带图灵机在多项式时间内可判定的语言类
语言𝐴的验证机$𝐴 = {𝑤|对某个字符串𝑐，𝑉接受 𝑤, 𝑐 }$，c为A的成员资格证书或证明
多项式 时间验证机-&gt;多项式可验证的

NP完全问题

这些问题中的任意一个如果存在多项式时间算法，那么所有问题都是多项式可解的。
如果语言B满足下面两个条件，则称为NP 完全的(NP-Complete):



$B$属于NP
NP中的每个$A$都多项式时间可规约到$B$




多项式时间可归约性：若存在多项式时间图灵机$𝑀$， 使得在任何输入$𝑤$上，$𝑀$停机时$𝑓(𝑤)$恰好在带子上，则称函数$𝑓: Σ^∗ → Σ^∗$为多项式时间可计算函数
若存在多项式时间可计算函数$𝑓: Σ^∗ → Σ^∗$， 对于每一个$𝑤$，有$𝑤∈𝐴$&lt;=&gt;$𝑓(𝑤)∈𝐵$，则$𝐴 ≤_𝑃 𝐵$
若$𝐴≤_𝑃 𝐵且𝐵∈𝑃$,则$𝐴∈𝑃$
若$B$是NP完全的，且$B∈P$，则$P=NP$
若$B$是NP完全的，且$B≤_pC$，$C$属于NP，则$C$是NP完全的
">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:49441/posts/%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:49441/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:49441/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:49441/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:49441/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:49441/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:49441/posts/%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg" crossorigin="anonymous"></script>


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

    <script type="text/javascript">
        document.addEventListener("DOMContentLoaded", function() {
          renderMathInElement(document.body, {
            delimiters: [
              {left: "$$", right: "$$", display: true},
              {left: "\\[", right: "\\]", display: true},
              {left: "$", right: "$", display: false},
              {left: "\\(", right: "\\)", display: false},
            ],
          });
        });
      </script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:49441/" accesskey="h" title="Jiajun, Shen (Alt + H)">Jiajun, Shen</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:49441/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:49441/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:49441/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:49441/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:49441/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:49441/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      理论计算机
    </h1>
    <div class="post-meta"><span title='2024-10-19 16:34:43 +0800 CST'>October 19, 2024</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e7%a1%ae%e5%ae%9a%e6%80%a7%e6%9c%89%e7%a9%b7%e8%87%aa%e5%8a%a8%e6%9c%ba" aria-label="确定性有穷自动机">确定性有穷自动机</a></li>
                <li>
                    <a href="#%e6%ad%a3%e5%88%99%e8%af%ad%e8%a8%80" aria-label="正则语言">正则语言</a></li>
                <li>
                    <a href="#%e9%9d%9e%e7%a1%ae%e5%ae%9a%e5%9e%8b%e6%9c%89%e7%a9%b7%e8%87%aa%e5%8a%a8%e6%9c%ba" aria-label="非确定型有穷自动机">非确定型有穷自动机</a></li>
                <li>
                    <a href="#nfa%e5%92%8cdfa%e7%9a%84%e7%ad%89%e4%bb%b7%e6%80%a7" aria-label="NFA和DFA的等价性">NFA和DFA的等价性</a></li>
                <li>
                    <a href="#%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f" aria-label="正则表达式">正则表达式</a></li>
                <li>
                    <a href="#%e6%b3%b5%e5%bc%95%e7%90%86" aria-label="泵引理">泵引理</a></li>
                <li>
                    <a href="#%e8%bf%88%e5%b8%8c%e5%b0%94-%e5%b0%bc%e7%bd%97%e5%be%b7%e5%ae%9a%e7%90%86" aria-label="迈希尔-尼罗德定理">迈希尔-尼罗德定理</a></li>
                <li>
                    <a href="#%e6%9e%81%e5%b0%8f%e5%8c%96dfa" aria-label="极小化DFA">极小化DFA</a></li>
                <li>
                    <a href="#%e5%88%a4%e6%96%addfa%e7%ad%89%e4%bb%b7%e6%80%a7" aria-label="判断DFA等价性">判断DFA等价性</a></li>
                <li>
                    <a href="#%e5%b8%a6%e8%be%93%e5%87%ba%e7%9a%84%e6%9c%89%e7%a9%b7%e8%87%aa%e5%8a%a8%e6%9c%ba" aria-label="带输出的有穷自动机">带输出的有穷自动机</a></li>
                <li>
                    <a href="#%e6%96%87%e6%b3%95" aria-label="文法">文法</a></li>
                <li>
                    <a href="#%e4%b8%8a%e4%b8%8b%e6%96%87%e6%97%a0%e5%85%b3%e6%96%87%e6%b3%95" aria-label="上下文无关文法">上下文无关文法</a></li>
                <li>
                    <a href="#%e4%b8%8b%e6%8e%a8%e8%87%aa%e5%8a%a8%e6%9c%ba" aria-label="下推自动机">下推自动机</a><ul>
                        
                <li>
                    <a href="#%e7%a1%ae%e5%ae%9a%e5%9e%8b%e4%b8%8b%e6%8e%a8%e8%87%aa%e5%8a%a8%e6%9c%ba" aria-label="确定型下推自动机">确定型下推自动机</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%9b%be%e7%81%b5%e6%9c%ba" aria-label="图灵机">图灵机</a></li>
                <li>
                    <a href="#%e5%bd%a2%e5%bc%8f%e8%af%ad%e8%a8%80%e4%b8%8e%e8%87%aa%e5%8a%a8%e6%9c%ba" aria-label="形式语言与自动机">形式语言与自动机</a></li>
                <li>
                    <a href="#%e7%ae%97%e6%b3%95" aria-label="算法">算法</a></li>
                <li>
                    <a href="#%e9%80%9a%e7%94%a8%e5%9b%be%e7%81%b5%e6%9c%ba" aria-label="通用图灵机">通用图灵机</a></li>
                <li>
                    <a href="#%e5%8f%af%e5%88%a4%e5%ae%9a%e8%af%ad%e8%a8%80" aria-label="可判定语言">可判定语言</a></li>
                <li>
                    <a href="#%e4%b8%8d%e5%8f%af%e5%88%a4%e5%ae%9a%e8%af%ad%e8%a8%80" aria-label="不可判定语言">不可判定语言</a></li>
                <li>
                    <a href="#%e6%98%a0%e5%b0%84%e5%8f%af%e8%a7%84%e7%ba%a6" aria-label="映射可规约">映射可规约</a></li>
                <li>
                    <a href="#%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e6%80%a7" aria-label="时间复杂性">时间复杂性</a></li>
                <li>
                    <a href="#p%e7%b1%bb%e4%b8%8enp%e7%b1%bb" aria-label="P类与NP类">P类与NP类</a><ul>
                        
                <li>
                    <a href="#p%e7%b1%bb" aria-label="P类">P类</a></li>
                <li>
                    <a href="#np%e7%b1%bb" aria-label="NP类">NP类</a></li>
                <li>
                    <a href="#np%e5%ae%8c%e5%85%a8%e9%97%ae%e9%a2%98" aria-label="NP完全问题">NP完全问题</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="确定性有穷自动机">确定性有穷自动机<a hidden class="anchor" aria-hidden="true" href="#确定性有穷自动机">#</a></h3>
<p>状态图 ：状态 ：起始状态(StartState)、接受状态(AcceptState)；转移：输入符号，从一个状态转移到另一个状态； 输出：接受或拒绝。
$M={Q,\Sigma,\delta,q_o,F}$ 字母代表状态集、字母表、转一函数、起始状态、接收状态集</p>
<h3 id="正则语言">正则语言<a hidden class="anchor" aria-hidden="true" href="#正则语言">#</a></h3>
<ul>
<li>语言(Language) ：某个给定字母表上的串(String)的可数集合</li>
<li>如果一个语言被一台有穷自动机识别，则称它是<strong>正则语言(Regular Language)</strong></li>
<li>正则运算：并、连接、星号</li>
<li>封闭性 ：正则运算、补、交</li>
<li>并的构造：新初始状态通过两个$\varepsilon$移动到两个自动机的起始状态</li>
<li>连接的构造：将第一个自动机的接受状态通过$\varepsilon$移动连接到第二个的初始状态</li>
<li>星号的构造：起始状态是一个接受状态，将新的起始状态和原来的接受状态用$\varepsilon$移动连到原来的起始状态</li>
</ul>
<h3 id="非确定型有穷自动机">非确定型有穷自动机<a hidden class="anchor" aria-hidden="true" href="#非确定型有穷自动机">#</a></h3>
<ul>
<li>给定当前状态，下一个状态可以不确定，可以包含$\varepsilon$移动，下一个状态可以并行选择</li>
<li>计算规则：移动产生备份，无法移动时，备份消失，有一个备份接受，整个计算就接受</li>
<li>$N={Q,\Sigma,\delta,q_o,F}$，转移函数$\delta:Q\times \Sigma_\varepsilon \rightarrow P(Q)$</li>
<li>$\varepsilon$-NFA：带有$\varepsilon$移动的NFA，可以转化为不含$\varepsilon$移动的NFA</li>
<li>$\varepsilon$-闭包：对每个状态经过$\varepsilon$移动可以到达的集合</li>
<li>修改状态转移表</li>
</ul>
<h3 id="nfa和dfa的等价性">NFA和DFA的等价性<a hidden class="anchor" aria-hidden="true" href="#nfa和dfa的等价性">#</a></h3>
<ul>
<li>每台NFA都有等价的DFA</li>
<li>NFA状态的幂集作为DFA的状态集，确定转移函数，去除冗余状态</li>
</ul>
<h3 id="正则表达式">正则表达式<a hidden class="anchor" aria-hidden="true" href="#正则表达式">#</a></h3>
<ul>
<li>R是正则表达式，如果R是$a,\varepsilon,\varnothing,(R_1+R_2),(R_1R_2),R_1^*$</li>
<li>正则表达式表达的语言为$L(R)$</li>
<li>如果一个语言可以用正则表达式描述，那么它是正则的</li>
<li>正则表达式转化为NFA：使用并、连接和星号的NFA构造即可</li>
<li>如果一个语言是正则的，则可以用正则表达式描述它</li>
<li>GNFA （广义非确定型有穷自动机，转移箭头可以用任何正则表达式作为标号）转化为正则表达式</li>
<li>任意挑选一个状态$q_{rip}$删去，修改每一个留下来的箭头上标记的正则表达式，得到更短的GNFA，直到最后。</li>
<li>$q_i$到$q_{rip}$有箭头$R_1$,$q_{rip}$到自己有箭头$R_2$，从$q_{rip}$到$q_j$有$R_3$，从$q_i$到$q_j$有$R_4$，则$q_i$到$q_j$的箭头为$(R_1)(R_2)^*(R_3)\cup(R_4)$</li>
<li>算数定律：</li>
<li>并的交换和结合律，单位元是$\varnothing$</li>
<li>连接的结合律（不满足交换），单位元是$\varepsilon$，零元是$\varnothing$</li>
<li>连接对并有左右分配律</li>
<li>交、并的幂等率$L+L=L$，$L\cap L=L$</li>
<li>闭包运算律：$(L^\star)^\star =L^\star $, $\varnothing^\star=\varepsilon$，$\varepsilon ^\star=\varepsilon$，$L^+=LL^*=L^*L$，$L^\star = L^+ + \varepsilon$</li>
<li>Arden引理 ：</li>
<li>$P$和$Q$是两个正则表达式，那么方 程$X=Q+XP$存在解$X=QP^*$。进一步地，如果$\varepsilon \notin L(P)$，则方程的解唯一</li>
<li>变量替换法化简正则表达式</li>
</ul>
<h3 id="泵引理">泵引理<a hidden class="anchor" aria-hidden="true" href="#泵引理">#</a></h3>
<ul>
<li>设$𝐴$是一个正则语言，则存在一个常数$𝑝$ (称为泵长度)，使得若$𝑠 ∈ 𝐴$且 $𝑠 ≥ 𝑝$，则$𝑠$可以被分成3段，𝑠 = 𝑥𝑦𝑧，并且满足下述条件：$∀𝑖 ≥ 0,𝑥𝑦^𝑖𝑧 ∈ 𝐴$, $|𝑦| &gt;0$, $|𝑥𝑦| ≤𝑝$</li>
<li>如果𝑝是语言𝐿的泵长度，则任意𝑝′ ≥ 𝑝也是语言 𝐿的泵长度。语言𝐿的最小泵长度是𝐿的泵长度的最小值</li>
<li>证明语言B不是正则的：精心选取字符串，根据泵引理证明无法抽取</li>
<li>泵引理仅仅是必要条件，满足泵引理不一定是正则语言</li>
</ul>
<h3 id="迈希尔-尼罗德定理">迈希尔-尼罗德定理<a hidden class="anchor" aria-hidden="true" href="#迈希尔-尼罗德定理">#</a></h3>
<ul>
<li>语言$𝐴$是正则的，当且仅当$≡_A$ 的等价类数目是有限的。如果$≡_A$ 将$Σ^∗$划分为$𝑛$个等价类，则识别$𝐴$的极小DFA恰好有$𝑛$个状态。</li>
<li>证明不是正则语言：证明有无穷个状态是可以区分的</li>
</ul>
<h3 id="极小化dfa">极小化DFA<a hidden class="anchor" aria-hidden="true" href="#极小化dfa">#</a></h3>
<ul>
<li>存在串$x$，使得两个状态一个到达接受，一个到达非接受，则这个串就去区分了两个状态，</li>
<li>存在串区分两个状态，这两个状态是可区分的，否则不可区分，不可区分的状态等价（死状态全部等价）</li>
<li>根据x长度可以区分$n$-等价，$n$-等价的状态不一定是不可区分的</li>
<li>等价状态划分</li>
<li>去掉不可达状态</li>
<li>逐个使用$0$-等价、$1$-等价……不停划分所有状态，直到不变，然后取代表元进行重建</li>
<li>填表法 ：</li>
<li>绘制表格，只要下半部分，去掉对角线以及右上部分</li>
<li>标记$(P,Q)$，其中$P \in F$, $Q\notin F$</li>
<li>迭代标记其他状态对（如果对一个输入产生的对已被标记，则进行标记）</li>
<li>合并等价状态，利用传递性合成</li>
</ul>
<h3 id="判断dfa等价性">判断DFA等价性<a hidden class="anchor" aria-hidden="true" href="#判断dfa等价性">#</a></h3>
<ul>
<li>检查两个状态是否同时为中间状态或终止状态，如果不是则不等价。</li>
<li>从两个初始状态开始对于所有的输入，如果出现新的状态对，继续分析，直到没有新的状态对，并且所有状态对都是同时为中间状态或终止状态</li>
</ul>
<h3 id="带输出的有穷自动机">带输出的有穷自动机<a hidden class="anchor" aria-hidden="true" href="#带输出的有穷自动机">#</a></h3>
<ul>
<li>米利机</li>
<li>输出是状态和输入的函数，输出不仅和当前状态有关，且和输入有关</li>
<li>$M={Q,\Sigma,\delta,\lambda,q_o,F}$, $\lambda: \Sigma\times Q\rightarrow \Delta$输出函数</li>
<li>米利机没有接受状态，不是一个语言识别器</li>
<li>在DFA的转移表的每一个输入中的新状态列后增加输出列</li>
<li>摩尔机</li>
<li>输出是状态的函数</li>
<li>在DFA的转移表后增加输出列</li>
<li>米利机和摩尔机的相互转化</li>
<li>摩尔机转化为米利机：新的输出函数$\lambda&rsquo;( q,a)=\lambda(\delta(q,a))$</li>
<li>米利机转化为摩尔机：
<ul>
<li>写出米利机对应的状态转移表</li>
<li>将被指向的状态中有不同输出的状态进行切分</li>
</ul>
</li>
</ul>
<h3 id="文法">文法<a hidden class="anchor" aria-hidden="true" href="#文法">#</a></h3>
<ul>
<li>概述</li>
<li>文法(Grammar)$𝐺$是一个四元组$𝐺 = (V,T,P,S)$，$V、T、P、S$分别表示语法变量（非终极符号、语法范畴）、终极符、产生式、开始符号。产生式：左部、右部、候选式</li>
<li>直接推导：$γαδ$=&gt;$_Gγβδ$，称$γβδ$在文法$G$中直接归约成$γαδ$</li>
<li>=&gt;$_G$、=&gt;$_G^+$、=&gt;$_G^*$、=&gt;$_G^n$</li>
<li>语法范畴代表的集合：语法变量能推出来的式子</li>
<li>文法的构造、文法的等价</li>
<li>正则文法</li>
<li>文法$G$叫做0型文法（短语结构文法）</li>
<li>1型文法：如果对于$\forall α→β∈P$，均有$|β|≥|α|$成立（上下文有关文法）</li>
<li>2型文法：如果对于$\forall α→β∈P$，均有$|β|≥|α|$成立，并且$α∈V$（上下文无关文法）</li>
<li>3型文法：如果对于$\forall α→β∈P$，具有形式$A→w$,$A→wB$-&gt;正则语言</li>
<li>线性文法：如果对于$\forall α→β∈P$，具有形式$A→w$,$A→wBx$</li>
<li>左线性文法：如果对于$\forall α→β∈P$，具有形式$A→w$,$A→Bw$</li>
<li>左/右线性文法产生的是正则语言，但是混用产生的不是正则文法。</li>
<li>空语句</li>
<li>约定：对于$G$中的任何变量$A$，在需 要的时候，可以出现形如$A→ε$的产生式。</li>
</ul>
<h3 id="上下文无关文法">上下文无关文法<a hidden class="anchor" aria-hidden="true" href="#上下文无关文法">#</a></h3>
<ul>
<li>产生式$P$具有如下形式：$𝐴 → 𝑥$， 其中，$𝐴∈𝑉$且$𝑥∈ (𝑉∪𝑇)^*$</li>
<li>派生树</li>
<li>派生树$T$的所有叶子顶点从左到右依次标记为$X_1，X_2，&hellip;，X_n$，则称符号串$X_1X_2&hellip;X_n$是$T$的结果</li>
<li>句型$α$的派生树：$G$的结果为$α$的派生树</li>
<li>$S$=&gt;$^*α$的充分必要条件为$G$有一棵结果为$α$的派生树</li>
<li><strong>最左派生</strong>(leftmost derivation)：$α$的派生过程中，每一步都是对当前句型的最左变量进行替换。<strong>左句型</strong>(left sentencial form)：最左派生得到的句型可叫做左句型。<strong>最右归约</strong>(rightmost reduction)：与最左派生对相的归约叫做最有归约。</li>
<li>最右派生=规范派生</li>
<li>如果$α$是$CFG$ $G$的一个句型，则G中存在$α$的最左派生和最右派生</li>
<li>如果$α$是$CFG$ $G$的一个句型，$α$的派生树与最左派生和最右派生是一 一对应的，但是， 这棵派生树可以对应多个不同的派生</li>
<li>二义性</li>
<li>$CFG$ $G=(V,T,P,S)$，如果存在$w∈L(G)$，$w$至少有两棵不同的派生树，则称$G$是二义性的。否则，$G$为非二义性的</li>
<li>消除二义性：规定运算的优先级/修改或重新设计文法</li>
<li>二义性的问题是不可解的(unsolvable)问题</li>
<li>如果语言$𝐿$不存在非二义性文法，则称$𝐿$是固有二义性的(inherent ambiguity)</li>
<li>解析</li>
<li>穷举搜索解析：利用所有产生式进行一步派生，验证是否匹配。自顶向下的解析、自底向上的解析。</li>
<li>计算效率低，对于$𝑤\notin𝐿(𝐺)$，上述过程可能永不终止。-&gt;去除空产生式和单一产生式</li>
<li>简单文法或𝒔-文法(s-grammar)： 如果它的所有产生式具有如下形式：$𝐴 → 𝑎𝑥$,
其中$𝐴 ∈ 𝑉$,$𝑎 ∈ 𝑇,𝑥 ∈ 𝑉^∗$, 且$(𝐴,𝑎)$在产生式$𝑃$中至多 出现一次。
<ul>
<li>若$𝐺$是$s$-文法，则对于$∀𝑤 ∈ 𝐿(𝐺)$，$𝑤$的解析复杂度正比于$|𝑤|$。</li>
</ul>
</li>
<li>化简</li>
<li>去除空产生式
<ul>
<li>首先利用如下算法找到$G$中所有可空变量构成的集合
<ul>
<li>对所有空产生式$𝐴 → 𝜀$，将$𝐴$放入$𝑉$
对所有如下产生式:$𝐵 → 𝐴_1𝐴_2 ⋯ 𝐴_𝑛$，其中$𝐴_𝑖 ∈ 𝑉 (1≤𝑖≤𝑛)$，将$𝐵$放入$𝑉 $中
重复第二步，直到没有变量可以加入$𝑉$为止</li>
</ul>
</li>
<li>考查$𝑃$中所有如下形式的产生式($A\rightarrow x,1\le|x|$)：将该产生式以及其中可空变量替换成$𝜀$后得到的所有产生式加入$𝑃$</li>
</ul>
</li>
<li>去除单一产生式
<ul>
<li>构造一个依赖图，边表示单一产生式</li>
<li>非单一产生式保留到$\hat{P}$，对于$A$=&gt;$^*B$的变元，加入$A$-&gt;$y_1|..|y_n$，y_1|..|y_n是$\hat{P}$中$B$在左端的所有产生式的候选式</li>
</ul>
</li>
<li>去除无用产生式
<ul>
<li>$𝐴$是有用的当且仅当$𝐴$出现在至少一个字符串的派生中</li>
<li>去除无法派生字符串的符号、去除起始变元不可达的符号</li>
</ul>
</li>
<li>范式</li>
<li>乔姆斯基范式
<ul>
<li>如果$CFG$ $𝐺 = (𝑉, 𝑇, 𝑃, 𝑆)$中的所有产生式 都具有形式：$A → 𝐵𝐶$ ,$𝐴→𝑎$，其中，$𝐴, 𝐵, 𝐶 ∈ 𝑉, 𝑎 ∈ 𝑇$，称$𝐺$为乔姆斯基范式文法</li>
<li>转化：对于过长的产生式引入新变量拆解</li>
</ul>
</li>
<li>格雷巴赫范式
<ul>
<li>如果$CFG$ $𝐺 = (𝑉, 𝑇, 𝑃, 𝑆)$中的所有产生式都具有形式：$𝐴 → 𝑎𝑥$，其中$𝐴 ∈ 𝑉, 𝑎 ∈ 𝑇, x ∈ V^∗$</li>
<li>CYK算法
<ul>
<li>$V_{ii}$是所有能产生字符串第$i$位的变量集合</li>
<li>$V_{ij}=\cup {A:A\rightarrow BC, B\in V_{ik},C \in V_{k+1,j}}$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="下推自动机">下推自动机<a hidden class="anchor" aria-hidden="true" href="#下推自动机">#</a></h3>
<ul>
<li>下推自动机𝑀是一个七元组：$M={Q,\Sigma,\Gamma, \delta,q_o,Z_0,F}$，$𝑍_0 ∈ Γ$称为开始符号(start symbol)，是𝑀启动 的时候栈内唯一的一个符号。习惯上又称为栈底符号，$\Gamma$是栈符号表(stack alphabet)。$∀𝐴 ∈ Γ$称作一个栈符号，状态转移函数$\delta:Q\times \Sigma\cup {\varepsilon}×Γ→2^{𝑄×Γ^∗}$</li>
<li>PDA的图形表示：$𝑎,𝑏→𝑐$表示机器从输入中读取$𝑎$时可以用$𝑐$替换栈顶
的符号$𝑏$，$𝑏 → 𝑐$读作: pop b, push c；$𝑎,𝑏,𝑐$中任何一个都可以是$\varepsilon$</li>
<li>PDA的即时描述：$\forall q,w,\gamma∈(𝑄,Σ^∗,Γ^∗)$称为$𝑀$的一个即时描述，$𝑤$是当前还未处理的输入字符串，$𝑀$正注视着$𝑤$的首字符；$𝛾$是堆栈中的符号，习惯上，$𝛾$的最<strong>左</strong>符号为<strong>栈顶符号</strong>，最<strong>右</strong>符号为<strong>栈底符号</strong></li>
<li>以终结状态方式接受、以空栈方式接受，两种方法是等价的</li>
<li>下推自动机可以识别上下文无关语言</li>
<li>对于给定的上下文无关语言$L$，存在一个PDA $M$使得$L=L(M)$
<ul>
<li>包含$\delta(q_0,\varepsilon,z)={(q_1,Sz)}$，压入起始符号</li>
<li>对格雷巴赫范式产生式$A\rightarrow au$存在转移$(q_1,u)\in \delta(q_1,a,A)$</li>
<li>$\delta(q_1,\varepsilon,z)={(q_f,z)}$进入接受状态</li>
</ul>
</li>
<li>如果一个语言被PDA识别，则该语言一定是上下文无关语言
<ul>
<li>构造（假设PDA一次只能pop或者push一个）
<ul>
<li>变元集${A_{pq}|p,q\in Q}$；起始变元$A_{q_0,q_{accept}}$</li>
<li>如果$\delta(p,a,\varepsilon)$包含$(r,u)$且$\delta(s,b,u)$包含$(q,\varepsilon)$，产生式加入$A_{pq}\rightarrow A_{pr}aA_{rs}b$</li>
<li>产生式加入$A_{pq}\rightarrow A_{pr}A_{rq}$</li>
<li>加入$A_{pp}\rightarrow \varepsilon$</li>
</ul>
</li>
<li>$A_{pq}$产生$x$，当且仅当$x$把$M$从状态$p$和空栈一起带到状态$q$和空栈</li>
</ul>
</li>
<li>CFL的 泵引理</li>
<li>设A是上下文无关语言, 则存在常数$𝑝$(泵长度)使得,若$𝑠∈𝐴$且$𝑠 ≥𝑝$,则 $𝑠 = 𝑢𝑣𝑥𝑦𝑧$且$\forall i \ge 0,uv^ixy^iz\in A$;$|vy|&gt;0$;$|vxy|\le p$</li>
<li>CFL的 封闭性</li>
<li>并、连接以及星号运算封闭，在交、补运算下不封闭</li>
<li>CFL与RL的交是CFL</li>
<li>$𝐿$是否为空的判定：算法去除文法中无用符号和无用产生式，如果起始变元$𝑆$是无用的，则$𝐿(𝐺)$是空集</li>
<li>$𝐿$是否有穷的判定</li>
<li>可派生性图表示</li>
</ul>
<h4 id="确定型下推自动机">确定型下推自动机<a hidden class="anchor" aria-hidden="true" href="#确定型下推自动机">#</a></h4>
<ul>
<li>每次移动仅有至多一种选择，确定型上下文无关语言可以进行高效的解析</li>
<li>对应的语言是$𝐿$被称为确定型上下文无关语言</li>
<li>DPDA与PDA不等价</li>
<li>如果一个文法，根据当前的输入符号以及随后的 𝑘 − 1个输入符号，可以唯一的确定下一步派生所需的产生式，则称该文法是𝐿𝐿(𝑘)文法</li>
</ul>
<h3 id="图灵机">图灵机<a hidden class="anchor" aria-hidden="true" href="#图灵机">#</a></h3>
<ul>
<li>等价于短语结构文法</li>
<li>TM $𝑀 = (𝑄, \Sigma, \Gamma, \delta, q_0, q_{acc}, q_{rej})$</li>
<li>格局表示为$uqav$；当前状态$𝑞$；当前带内容$uav$；当前扫描符号$a$</li>
<li>判定器：所有输入都停机的图灵机，它们永不循环，称这种图灵机为判定器</li>
<li>图灵可识别：接受、拒绝或不停机；图灵可判定：处处停机</li>
<li>变形</li>
<li>多带图灵机</li>
<li>多维图灵机</li>
<li>非确定性图灵机</li>
<li>枚举器（图灵可识别&lt;=&gt;存在枚举器枚举）</li>
</ul>
<h3 id="形式语言与自动机">形式语言与自动机<a hidden class="anchor" aria-hidden="true" href="#形式语言与自动机">#</a></h3>
<ul>
<li>线性有界自动机LBA是一种受限的图灵机，不允许其读写头离开包含输入的带子区域</li>
<li>线性有界自动机等价上下文有关文法</li>
</ul>
<h3 id="算法">算法<a hidden class="anchor" aria-hidden="true" href="#算法">#</a></h3>
<ul>
<li>图灵机算法的描述方式</li>
<li>形式化描述
<ul>
<li>七元组。对图灵机最低层次、最详细程度的描述</li>
</ul>
</li>
<li>实现描述
<ul>
<li>用日常语言描述图灵机的运行(如何存放数据,如何移动读写头)</li>
<li>不给出状态和转移函数的细节</li>
</ul>
</li>
<li>高层次描述
<ul>
<li>用日常语言描述算法</li>
<li>不考虑对读写头和带的管理</li>
</ul>
</li>
</ul>
<h3 id="通用图灵机">通用图灵机<a hidden class="anchor" aria-hidden="true" href="#通用图灵机">#</a></h3>
<ul>
<li>存放图灵机的编码、存放图灵机带子的内容、存放图灵机的内部状态</li>
<li>所有图灵机构成的集合是一个可数集</li>
</ul>
<h3 id="可判定语言">可判定语言<a hidden class="anchor" aria-hidden="true" href="#可判定语言">#</a></h3>
<ul>
<li>如果存在一个处处停机的图灵机，能够判定给定 的字符串是否属于该语言</li>
<li>与正则语言相关的可判定性问题</li>
<li>DFA接受问题：一个有穷自动机是否接受一个串 ✅</li>
<li>NFA接受问题 ✅</li>
<li>正则表达式派生问题 ✅</li>
<li>DFA空性问题：一个DFA是否根本不接受任何串? ✅</li>
<li>DFA等价性问题：检查两个DFA是否识别同一个语言 ✅
<ul>
<li>正则语言对对称差封闭</li>
</ul>
</li>
<li>CFG 接受性和空性 ✅</li>
</ul>
<h3 id="不可判定语言">不可判定语言<a hidden class="anchor" aria-hidden="true" href="#不可判定语言">#</a></h3>
<ul>
<li>检查一个图灵机是否接受一个给定的串 ❌ (但是可识别)</li>
<li>存在不能被任何图灵机识别的语言（语言集合不可数）</li>
<li>可判定&lt;=&gt;语言和它的补都可识别，可以推出$\bar{A_{TM}}$不可识别</li>
<li>CFG等价性 ❌</li>
<li>TM空性 ❌</li>
<li>修改图灵机，拒绝w以外的所有输入，在w上模拟原图灵机</li>
<li>然后判定是否为空，得到A_{TM}可判定，矛盾</li>
<li>等价性（检查两个给定的图灵机是否识别相同的语言）❌</li>
<li>从空性开始规约</li>
<li>停机问题HALT_{TM} ❌</li>
<li>正则性（检查给定图灵机有没有等价的有穷自动机） ❌</li>
<li>假设能够判定，构造M_{2}在输入x上，接受$0^n1^n$，其他串模拟M</li>
<li>在输入M_{2}运行R，R接受则接受，拒绝则拒绝</li>
<li>M_{2}自动接受${0^n1^n|n \ge 0}$中的所有串，如果M_{2}接受w, M_{2}就接受所有其他串</li>
<li>波斯特对应问题 ❌</li>
</ul>
<h3 id="映射可规约">映射可规约<a hidden class="anchor" aria-hidden="true" href="#映射可规约">#</a></h3>
<ul>
<li>设$A$和$𝐵$是语言，如果存在可计算函数 $𝑓:Σ^∗ →Σ^∗$，使得对于每个$𝑥$，$𝑥∈𝐴$⟺$𝑓 (𝑥) ∈ 𝐵$, 则称语言$A$映射可归约到语言$𝐵$, 记作$𝐴 ≤_𝑚 𝐵$. 称函数$𝑓$为从$A$到$B$的归约，记作$𝐴 ≤_𝑚 𝐵$ via $𝑓$</li>
<li>如果$𝐴 ≤_𝑚 𝐵$且$𝐵$是<strong>可判定</strong>的，则$𝐴$也是可判定的。可判定语言类在映射可归约下封闭（逆否：如果𝐴 ≤𝑚 𝐵且A是不可判定的，则B也 是不可判定的）</li>
<li>映射归约具有传递性，即: 若$𝐴≤_𝑚𝐵$,且𝐵$≤_𝑚 𝐶$,则$𝐴≤_𝑚 𝐶$</li>
<li>若$𝐴 ≤_𝑚 𝐵$, 且$𝐵$是图灵<strong>可识别</strong>的$，则$A$也是图灵可识别的</li>
<li>为证$𝐵$不是图灵可识别的，可以证明$𝐴 ≤_m \bar{𝐵}$</li>
</ul>
<h3 id="时间复杂性">时间复杂性<a hidden class="anchor" aria-hidden="true" href="#时间复杂性">#</a></h3>
<ul>
<li>时间复杂度是一个函数：$𝑓(𝑛)$是M在所有长度为$𝑛$的输入上运行时所经过的最大步数</li>
<li>渐进分析方法、渐进上界</li>
<li>大O($\le$)和小o($&lt;$)记法</li>
<li><strong>时间复杂性类</strong>：令$𝑡: 𝑁 → 𝑅^+$是一个函数。 TIME$(𝑡(n))$为由$𝑂 (𝑡(𝑛))$ 时间的图灵机判定的所有语言的集合</li>
<li>单带图灵机在$𝑜(𝑛\log 𝑛)$时间内判定的语言都是正则语言。</li>
<li><em>注意：在==可计算理论==中，丘奇-图灵论题断言：所有合理的计算模型都是等价的，即他们所判定的语言类都是相同的；在==复杂性理论==中，模型的选择影响语言的时间复杂度</em></li>
<li>设$𝑡(𝑛)$是一个函数，$𝑡 (𝑛) ≥ 𝑛$。则每一个$𝑡(𝑛)$时间的多带图灵机都和某一个$𝑂(𝑡^2(𝑛))$ 时间的单带图灵机等价</li>
<li>设$𝑡(𝑛)$是一个函数，且$𝑡 (𝑛) ≥ 𝑛$。 则每一个$𝑡(𝑛)$时间的非确定型单带图灵机都与某一个$2^{𝑂(𝑡(𝑛))}$ 时间的确定型单带图灵机等价</li>
</ul>
<h3 id="p类与np类">P类与NP类<a hidden class="anchor" aria-hidden="true" href="#p类与np类">#</a></h3>
<h4 id="p类">P类<a hidden class="anchor" aria-hidden="true" href="#p类">#</a></h4>
<ul>
<li>能在多项式时间内可判定的语言类</li>
<li>稳健：对于所有和确定型单带图灵机多项式等价的计算模型来说，P是不变的</li>
<li>实用：P大致对应于在计算机上实际可解的(tractable)那一类问题</li>
</ul>
<h4 id="np类">NP类<a hidden class="anchor" aria-hidden="true" href="#np类">#</a></h4>
<ul>
<li>NP是非确定型单带图灵机在多项式时间内可判定的语言类</li>
<li>语言𝐴的验证机$𝐴 = {𝑤|对某个字符串𝑐，𝑉接受 𝑤, 𝑐 }$，c为A的成员资格证书或证明</li>
<li>多项式 时间验证机-&gt;多项式可验证的</li>
</ul>
<h4 id="np完全问题">NP完全问题<a hidden class="anchor" aria-hidden="true" href="#np完全问题">#</a></h4>
<ul>
<li>这些问题中的任意一个如果存在多项式时间算法，那么所有问题都是多项式可解的。</li>
<li>如果语言B满足下面两个条件，则称为NP 完全的(NP-Complete):
<ul>
<li>
<ol>
<li>$B$属于NP</li>
<li>NP中的每个$A$都多项式时间可规约到$B$</li>
</ol>
</li>
</ul>
</li>
<li>多项式时间可归约性：若存在多项式时间图灵机$𝑀$， 使得在任何输入$𝑤$上，$𝑀$停机时$𝑓(𝑤)$恰好在带子上，则称函数$𝑓: Σ^∗ → Σ^∗$为多项式时间可计算函数</li>
<li>若存在多项式时间可计算函数$𝑓: Σ^∗ → Σ^∗$， 对于每一个$𝑤$，有$𝑤∈𝐴$&lt;=&gt;$𝑓(𝑤)∈𝐵$，则$𝐴 ≤_𝑃 𝐵$</li>
<li>若$𝐴≤_𝑃 𝐵且𝐵∈𝑃$,则$𝐴∈𝑃$</li>
<li>若$B$是NP完全的，且$B∈P$，则$P=NP$</li>
<li>若$B$是NP完全的，且$B≤_pC$，$C$属于NP，则$C$是NP完全的</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:49441/tags/cs/">CS</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:49441/">Jiajun, Shen</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
