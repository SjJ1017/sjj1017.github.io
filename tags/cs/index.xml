<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>CS on Jiajun, Shen</title>
    <link>https://sjj1017.github.io/tags/cs/</link>
    <description>Recent content in CS on Jiajun, Shen</description>
    <generator>Hugo -- 0.136.2</generator>
    <language>en</language>
    <lastBuildDate>Sat, 19 Oct 2024 16:34:43 +0800</lastBuildDate>
    <atom:link href="https://sjj1017.github.io/tags/cs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>理论计算机</title>
      <link>https://sjj1017.github.io/posts/%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA/</link>
      <pubDate>Sat, 19 Oct 2024 16:34:43 +0800</pubDate>
      <guid>https://sjj1017.github.io/posts/%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA/</guid>
      <description>&lt;h3 id=&#34;确定性有穷自动机&#34;&gt;确定性有穷自动机&lt;/h3&gt;
&lt;p&gt;状态图 ：状态 ：起始状态(StartState)、接受状态(AcceptState)；转移：输入符号，从一个状态转移到另一个状态； 输出：接受或拒绝。
$M={Q,\Sigma,\delta,q_o,F}$ 字母代表状态集、字母表、转一函数、起始状态、接收状态集&lt;/p&gt;
&lt;h3 id=&#34;正则语言&#34;&gt;正则语言&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;语言(Language) ：某个给定字母表上的串(String)的可数集合&lt;/li&gt;
&lt;li&gt;如果一个语言被一台有穷自动机识别，则称它是&lt;strong&gt;正则语言(Regular Language)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;正则运算：并、连接、星号&lt;/li&gt;
&lt;li&gt;封闭性 ：正则运算、补、交&lt;/li&gt;
&lt;li&gt;并的构造：新初始状态通过两个$\varepsilon$移动到两个自动机的起始状态&lt;/li&gt;
&lt;li&gt;连接的构造：将第一个自动机的接受状态通过$\varepsilon$移动连接到第二个的初始状态&lt;/li&gt;
&lt;li&gt;星号的构造：起始状态是一个接受状态，将新的起始状态和原来的接受状态用$\varepsilon$移动连到原来的起始状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;非确定型有穷自动机&#34;&gt;非确定型有穷自动机&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;给定当前状态，下一个状态可以不确定，可以包含$\varepsilon$移动，下一个状态可以并行选择&lt;/li&gt;
&lt;li&gt;计算规则：移动产生备份，无法移动时，备份消失，有一个备份接受，整个计算就接受&lt;/li&gt;
&lt;li&gt;$N={Q,\Sigma,\delta,q_o,F}$，转移函数$\delta:Q\times \Sigma_\varepsilon \rightarrow P(Q)$&lt;/li&gt;
&lt;li&gt;$\varepsilon$-NFA：带有$\varepsilon$移动的NFA，可以转化为不含$\varepsilon$移动的NFA&lt;/li&gt;
&lt;li&gt;$\varepsilon$-闭包：对每个状态经过$\varepsilon$移动可以到达的集合&lt;/li&gt;
&lt;li&gt;修改状态转移表&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;nfa和dfa的等价性&#34;&gt;NFA和DFA的等价性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每台NFA都有等价的DFA&lt;/li&gt;
&lt;li&gt;NFA状态的幂集作为DFA的状态集，确定转移函数，去除冗余状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;正则表达式&#34;&gt;正则表达式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;R是正则表达式，如果R是$a,\varepsilon,\varnothing,(R_1+R_2),(R_1R_2),R_1^*$&lt;/li&gt;
&lt;li&gt;正则表达式表达的语言为$L(R)$&lt;/li&gt;
&lt;li&gt;如果一个语言可以用正则表达式描述，那么它是正则的&lt;/li&gt;
&lt;li&gt;正则表达式转化为NFA：使用并、连接和星号的NFA构造即可&lt;/li&gt;
&lt;li&gt;如果一个语言是正则的，则可以用正则表达式描述它&lt;/li&gt;
&lt;li&gt;GNFA （广义非确定型有穷自动机，转移箭头可以用任何正则表达式作为标号）转化为正则表达式&lt;/li&gt;
&lt;li&gt;任意挑选一个状态$q_{rip}$删去，修改每一个留下来的箭头上标记的正则表达式，得到更短的GNFA，直到最后。&lt;/li&gt;
&lt;li&gt;$q_i$到$q_{rip}$有箭头$R_1$,$q_{rip}$到自己有箭头$R_2$，从$q_{rip}$到$q_j$有$R_3$，从$q_i$到$q_j$有$R_4$，则$q_i$到$q_j$的箭头为$(R_1)(R_2)^*(R_3)\cup(R_4)$&lt;/li&gt;
&lt;li&gt;算数定律：&lt;/li&gt;
&lt;li&gt;并的交换和结合律，单位元是$\varnothing$&lt;/li&gt;
&lt;li&gt;连接的结合律（不满足交换），单位元是$\varepsilon$，零元是$\varnothing$&lt;/li&gt;
&lt;li&gt;连接对并有左右分配律&lt;/li&gt;
&lt;li&gt;交、并的幂等率$L+L=L$，$L\cap L=L$&lt;/li&gt;
&lt;li&gt;闭包运算律：$(L^\star)^\star =L^\star $, $\varnothing^\star=\varepsilon$，$\varepsilon ^\star=\varepsilon$，$L^+=LL^*=L^*L$，$L^\star = L^+ + \varepsilon$&lt;/li&gt;
&lt;li&gt;Arden引理 ：&lt;/li&gt;
&lt;li&gt;$P$和$Q$是两个正则表达式，那么方 程$X=Q+XP$存在解$X=QP^*$。进一步地，如果$\varepsilon \notin L(P)$，则方程的解唯一&lt;/li&gt;
&lt;li&gt;变量替换法化简正则表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;泵引理&#34;&gt;泵引理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;设$𝐴$是一个正则语言，则存在一个常数$𝑝$ (称为泵长度)，使得若$𝑠 ∈ 𝐴$且 $𝑠 ≥ 𝑝$，则$𝑠$可以被分成3段，𝑠 = 𝑥𝑦𝑧，并且满足下述条件：$∀𝑖 ≥ 0,𝑥𝑦^𝑖𝑧 ∈ 𝐴$, $|𝑦| &amp;gt;0$, $|𝑥𝑦| ≤𝑝$&lt;/li&gt;
&lt;li&gt;如果𝑝是语言𝐿的泵长度，则任意𝑝′ ≥ 𝑝也是语言 𝐿的泵长度。语言𝐿的最小泵长度是𝐿的泵长度的最小值&lt;/li&gt;
&lt;li&gt;证明语言B不是正则的：精心选取字符串，根据泵引理证明无法抽取&lt;/li&gt;
&lt;li&gt;泵引理仅仅是必要条件，满足泵引理不一定是正则语言&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;迈希尔-尼罗德定理&#34;&gt;迈希尔-尼罗德定理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;语言$𝐴$是正则的，当且仅当$≡_A$ 的等价类数目是有限的。如果$≡_A$ 将$Σ^∗$划分为$𝑛$个等价类，则识别$𝐴$的极小DFA恰好有$𝑛$个状态。&lt;/li&gt;
&lt;li&gt;证明不是正则语言：证明有无穷个状态是可以区分的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;极小化dfa&#34;&gt;极小化DFA&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;存在串$x$，使得两个状态一个到达接受，一个到达非接受，则这个串就去区分了两个状态，&lt;/li&gt;
&lt;li&gt;存在串区分两个状态，这两个状态是可区分的，否则不可区分，不可区分的状态等价（死状态全部等价）&lt;/li&gt;
&lt;li&gt;根据x长度可以区分$n$-等价，$n$-等价的状态不一定是不可区分的&lt;/li&gt;
&lt;li&gt;等价状态划分&lt;/li&gt;
&lt;li&gt;去掉不可达状态&lt;/li&gt;
&lt;li&gt;逐个使用$0$-等价、$1$-等价……不停划分所有状态，直到不变，然后取代表元进行重建&lt;/li&gt;
&lt;li&gt;填表法 ：&lt;/li&gt;
&lt;li&gt;绘制表格，只要下半部分，去掉对角线以及右上部分&lt;/li&gt;
&lt;li&gt;标记$(P,Q)$，其中$P \in F$, $Q\notin F$&lt;/li&gt;
&lt;li&gt;迭代标记其他状态对（如果对一个输入产生的对已被标记，则进行标记）&lt;/li&gt;
&lt;li&gt;合并等价状态，利用传递性合成&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;判断dfa等价性&#34;&gt;判断DFA等价性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;检查两个状态是否同时为中间状态或终止状态，如果不是则不等价。&lt;/li&gt;
&lt;li&gt;从两个初始状态开始对于所有的输入，如果出现新的状态对，继续分析，直到没有新的状态对，并且所有状态对都是同时为中间状态或终止状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;带输出的有穷自动机&#34;&gt;带输出的有穷自动机&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;米利机&lt;/li&gt;
&lt;li&gt;输出是状态和输入的函数，输出不仅和当前状态有关，且和输入有关&lt;/li&gt;
&lt;li&gt;$M={Q,\Sigma,\delta,\lambda,q_o,F}$, $\lambda: \Sigma\times Q\rightarrow \Delta$输出函数&lt;/li&gt;
&lt;li&gt;米利机没有接受状态，不是一个语言识别器&lt;/li&gt;
&lt;li&gt;在DFA的转移表的每一个输入中的新状态列后增加输出列&lt;/li&gt;
&lt;li&gt;摩尔机&lt;/li&gt;
&lt;li&gt;输出是状态的函数&lt;/li&gt;
&lt;li&gt;在DFA的转移表后增加输出列&lt;/li&gt;
&lt;li&gt;米利机和摩尔机的相互转化&lt;/li&gt;
&lt;li&gt;摩尔机转化为米利机：新的输出函数$\lambda&amp;rsquo;( q,a)=\lambda(\delta(q,a))$&lt;/li&gt;
&lt;li&gt;米利机转化为摩尔机：
&lt;ul&gt;
&lt;li&gt;写出米利机对应的状态转移表&lt;/li&gt;
&lt;li&gt;将被指向的状态中有不同输出的状态进行切分&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;文法&#34;&gt;文法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;概述&lt;/li&gt;
&lt;li&gt;文法(Grammar)$𝐺$是一个四元组$𝐺 = (V,T,P,S)$，$V、T、P、S$分别表示语法变量（非终极符号、语法范畴）、终极符、产生式、开始符号。产生式：左部、右部、候选式&lt;/li&gt;
&lt;li&gt;直接推导：$γαδ$=&amp;gt;$_Gγβδ$，称$γβδ$在文法$G$中直接归约成$γαδ$&lt;/li&gt;
&lt;li&gt;=&amp;gt;$_G$、=&amp;gt;$_G^+$、=&amp;gt;$_G^*$、=&amp;gt;$_G^n$&lt;/li&gt;
&lt;li&gt;语法范畴代表的集合：语法变量能推出来的式子&lt;/li&gt;
&lt;li&gt;文法的构造、文法的等价&lt;/li&gt;
&lt;li&gt;正则文法&lt;/li&gt;
&lt;li&gt;文法$G$叫做0型文法（短语结构文法）&lt;/li&gt;
&lt;li&gt;1型文法：如果对于$\forall α→β∈P$，均有$|β|≥|α|$成立（上下文有关文法）&lt;/li&gt;
&lt;li&gt;2型文法：如果对于$\forall α→β∈P$，均有$|β|≥|α|$成立，并且$α∈V$（上下文无关文法）&lt;/li&gt;
&lt;li&gt;3型文法：如果对于$\forall α→β∈P$，具有形式$A→w$,$A→wB$-&amp;gt;正则语言&lt;/li&gt;
&lt;li&gt;线性文法：如果对于$\forall α→β∈P$，具有形式$A→w$,$A→wBx$&lt;/li&gt;
&lt;li&gt;左线性文法：如果对于$\forall α→β∈P$，具有形式$A→w$,$A→Bw$&lt;/li&gt;
&lt;li&gt;左/右线性文法产生的是正则语言，但是混用产生的不是正则文法。&lt;/li&gt;
&lt;li&gt;空语句&lt;/li&gt;
&lt;li&gt;约定：对于$G$中的任何变量$A$，在需 要的时候，可以出现形如$A→ε$的产生式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;上下文无关文法&#34;&gt;上下文无关文法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;产生式$P$具有如下形式：$𝐴 → 𝑥$， 其中，$𝐴∈𝑉$且$𝑥∈ (𝑉∪𝑇)^*$&lt;/li&gt;
&lt;li&gt;派生树&lt;/li&gt;
&lt;li&gt;派生树$T$的所有叶子顶点从左到右依次标记为$X_1，X_2，&amp;hellip;，X_n$，则称符号串$X_1X_2&amp;hellip;X_n$是$T$的结果&lt;/li&gt;
&lt;li&gt;句型$α$的派生树：$G$的结果为$α$的派生树&lt;/li&gt;
&lt;li&gt;$S$=&amp;gt;$^*α$的充分必要条件为$G$有一棵结果为$α$的派生树&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最左派生&lt;/strong&gt;(leftmost derivation)：$α$的派生过程中，每一步都是对当前句型的最左变量进行替换。&lt;strong&gt;左句型&lt;/strong&gt;(left sentencial form)：最左派生得到的句型可叫做左句型。&lt;strong&gt;最右归约&lt;/strong&gt;(rightmost reduction)：与最左派生对相的归约叫做最有归约。&lt;/li&gt;
&lt;li&gt;最右派生=规范派生&lt;/li&gt;
&lt;li&gt;如果$α$是$CFG$ $G$的一个句型，则G中存在$α$的最左派生和最右派生&lt;/li&gt;
&lt;li&gt;如果$α$是$CFG$ $G$的一个句型，$α$的派生树与最左派生和最右派生是一 一对应的，但是， 这棵派生树可以对应多个不同的派生&lt;/li&gt;
&lt;li&gt;二义性&lt;/li&gt;
&lt;li&gt;$CFG$ $G=(V,T,P,S)$，如果存在$w∈L(G)$，$w$至少有两棵不同的派生树，则称$G$是二义性的。否则，$G$为非二义性的&lt;/li&gt;
&lt;li&gt;消除二义性：规定运算的优先级/修改或重新设计文法&lt;/li&gt;
&lt;li&gt;二义性的问题是不可解的(unsolvable)问题&lt;/li&gt;
&lt;li&gt;如果语言$𝐿$不存在非二义性文法，则称$𝐿$是固有二义性的(inherent ambiguity)&lt;/li&gt;
&lt;li&gt;解析&lt;/li&gt;
&lt;li&gt;穷举搜索解析：利用所有产生式进行一步派生，验证是否匹配。自顶向下的解析、自底向上的解析。&lt;/li&gt;
&lt;li&gt;计算效率低，对于$𝑤\notin𝐿(𝐺)$，上述过程可能永不终止。-&amp;gt;去除空产生式和单一产生式&lt;/li&gt;
&lt;li&gt;简单文法或𝒔-文法(s-grammar)： 如果它的所有产生式具有如下形式：$𝐴 → 𝑎𝑥$,
其中$𝐴 ∈ 𝑉$,$𝑎 ∈ 𝑇,𝑥 ∈ 𝑉^∗$, 且$(𝐴,𝑎)$在产生式$𝑃$中至多 出现一次。
&lt;ul&gt;
&lt;li&gt;若$𝐺$是$s$-文法，则对于$∀𝑤 ∈ 𝐿(𝐺)$，$𝑤$的解析复杂度正比于$|𝑤|$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;化简&lt;/li&gt;
&lt;li&gt;去除空产生式
&lt;ul&gt;
&lt;li&gt;首先利用如下算法找到$G$中所有可空变量构成的集合
&lt;ul&gt;
&lt;li&gt;对所有空产生式$𝐴 → 𝜀$，将$𝐴$放入$𝑉$
对所有如下产生式:$𝐵 → 𝐴_1𝐴_2 ⋯ 𝐴_𝑛$，其中$𝐴_𝑖 ∈ 𝑉 (1≤𝑖≤𝑛)$，将$𝐵$放入$𝑉 $中
重复第二步，直到没有变量可以加入$𝑉$为止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;考查$𝑃$中所有如下形式的产生式($A\rightarrow x,1\le|x|$)：将该产生式以及其中可空变量替换成$𝜀$后得到的所有产生式加入$𝑃$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;去除单一产生式
&lt;ul&gt;
&lt;li&gt;构造一个依赖图，边表示单一产生式&lt;/li&gt;
&lt;li&gt;非单一产生式保留到$\hat{P}$，对于$A$=&amp;gt;$^*B$的变元，加入$A$-&amp;gt;$y_1|..|y_n$，y_1|..|y_n是$\hat{P}$中$B$在左端的所有产生式的候选式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;去除无用产生式
&lt;ul&gt;
&lt;li&gt;$𝐴$是有用的当且仅当$𝐴$出现在至少一个字符串的派生中&lt;/li&gt;
&lt;li&gt;去除无法派生字符串的符号、去除起始变元不可达的符号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;范式&lt;/li&gt;
&lt;li&gt;乔姆斯基范式
&lt;ul&gt;
&lt;li&gt;如果$CFG$ $𝐺 = (𝑉, 𝑇, 𝑃, 𝑆)$中的所有产生式 都具有形式：$A → 𝐵𝐶$ ,$𝐴→𝑎$，其中，$𝐴, 𝐵, 𝐶 ∈ 𝑉, 𝑎 ∈ 𝑇$，称$𝐺$为乔姆斯基范式文法&lt;/li&gt;
&lt;li&gt;转化：对于过长的产生式引入新变量拆解&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;格雷巴赫范式
&lt;ul&gt;
&lt;li&gt;如果$CFG$ $𝐺 = (𝑉, 𝑇, 𝑃, 𝑆)$中的所有产生式都具有形式：$𝐴 → 𝑎𝑥$，其中$𝐴 ∈ 𝑉, 𝑎 ∈ 𝑇, x ∈ V^∗$&lt;/li&gt;
&lt;li&gt;CYK算法
&lt;ul&gt;
&lt;li&gt;$V_{ii}$是所有能产生字符串第$i$位的变量集合&lt;/li&gt;
&lt;li&gt;$V_{ij}=\cup {A:A\rightarrow BC, B\in V_{ik},C \in V_{k+1,j}}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;下推自动机&#34;&gt;下推自动机&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;下推自动机𝑀是一个七元组：$M={Q,\Sigma,\Gamma, \delta,q_o,Z_0,F}$，$𝑍_0 ∈ Γ$称为开始符号(start symbol)，是𝑀启动 的时候栈内唯一的一个符号。习惯上又称为栈底符号，$\Gamma$是栈符号表(stack alphabet)。$∀𝐴 ∈ Γ$称作一个栈符号，状态转移函数$\delta:Q\times \Sigma\cup {\varepsilon}×Γ→2^{𝑄×Γ^∗}$&lt;/li&gt;
&lt;li&gt;PDA的图形表示：$𝑎,𝑏→𝑐$表示机器从输入中读取$𝑎$时可以用$𝑐$替换栈顶
的符号$𝑏$，$𝑏 → 𝑐$读作: pop b, push c；$𝑎,𝑏,𝑐$中任何一个都可以是$\varepsilon$&lt;/li&gt;
&lt;li&gt;PDA的即时描述：$\forall q,w,\gamma∈(𝑄,Σ^∗,Γ^∗)$称为$𝑀$的一个即时描述，$𝑤$是当前还未处理的输入字符串，$𝑀$正注视着$𝑤$的首字符；$𝛾$是堆栈中的符号，习惯上，$𝛾$的最&lt;strong&gt;左&lt;/strong&gt;符号为&lt;strong&gt;栈顶符号&lt;/strong&gt;，最&lt;strong&gt;右&lt;/strong&gt;符号为&lt;strong&gt;栈底符号&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;以终结状态方式接受、以空栈方式接受，两种方法是等价的&lt;/li&gt;
&lt;li&gt;下推自动机可以识别上下文无关语言&lt;/li&gt;
&lt;li&gt;对于给定的上下文无关语言$L$，存在一个PDA $M$使得$L=L(M)$
&lt;ul&gt;
&lt;li&gt;包含$\delta(q_0,\varepsilon,z)={(q_1,Sz)}$，压入起始符号&lt;/li&gt;
&lt;li&gt;对格雷巴赫范式产生式$A\rightarrow au$存在转移$(q_1,u)\in \delta(q_1,a,A)$&lt;/li&gt;
&lt;li&gt;$\delta(q_1,\varepsilon,z)={(q_f,z)}$进入接受状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果一个语言被PDA识别，则该语言一定是上下文无关语言
&lt;ul&gt;
&lt;li&gt;构造（假设PDA一次只能pop或者push一个）
&lt;ul&gt;
&lt;li&gt;变元集${A_{pq}|p,q\in Q}$；起始变元$A_{q_0,q_{accept}}$&lt;/li&gt;
&lt;li&gt;如果$\delta(p,a,\varepsilon)$包含$(r,u)$且$\delta(s,b,u)$包含$(q,\varepsilon)$，产生式加入$A_{pq}\rightarrow A_{pr}aA_{rs}b$&lt;/li&gt;
&lt;li&gt;产生式加入$A_{pq}\rightarrow A_{pr}A_{rq}$&lt;/li&gt;
&lt;li&gt;加入$A_{pp}\rightarrow \varepsilon$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$A_{pq}$产生$x$，当且仅当$x$把$M$从状态$p$和空栈一起带到状态$q$和空栈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CFL的 泵引理&lt;/li&gt;
&lt;li&gt;设A是上下文无关语言, 则存在常数$𝑝$(泵长度)使得,若$𝑠∈𝐴$且$𝑠 ≥𝑝$,则 $𝑠 = 𝑢𝑣𝑥𝑦𝑧$且$\forall i \ge 0,uv^ixy^iz\in A$;$|vy|&amp;gt;0$;$|vxy|\le p$&lt;/li&gt;
&lt;li&gt;CFL的 封闭性&lt;/li&gt;
&lt;li&gt;并、连接以及星号运算封闭，在交、补运算下不封闭&lt;/li&gt;
&lt;li&gt;CFL与RL的交是CFL&lt;/li&gt;
&lt;li&gt;$𝐿$是否为空的判定：算法去除文法中无用符号和无用产生式，如果起始变元$𝑆$是无用的，则$𝐿(𝐺)$是空集&lt;/li&gt;
&lt;li&gt;$𝐿$是否有穷的判定&lt;/li&gt;
&lt;li&gt;可派生性图表示&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;确定型下推自动机&#34;&gt;确定型下推自动机&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;每次移动仅有至多一种选择，确定型上下文无关语言可以进行高效的解析&lt;/li&gt;
&lt;li&gt;对应的语言是$𝐿$被称为确定型上下文无关语言&lt;/li&gt;
&lt;li&gt;DPDA与PDA不等价&lt;/li&gt;
&lt;li&gt;如果一个文法，根据当前的输入符号以及随后的 𝑘 − 1个输入符号，可以唯一的确定下一步派生所需的产生式，则称该文法是𝐿𝐿(𝑘)文法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;图灵机&#34;&gt;图灵机&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;等价于短语结构文法&lt;/li&gt;
&lt;li&gt;TM $𝑀 = (𝑄, \Sigma, \Gamma, \delta, q_0, q_{acc}, q_{rej})$&lt;/li&gt;
&lt;li&gt;格局表示为$uqav$；当前状态$𝑞$；当前带内容$uav$；当前扫描符号$a$&lt;/li&gt;
&lt;li&gt;判定器：所有输入都停机的图灵机，它们永不循环，称这种图灵机为判定器&lt;/li&gt;
&lt;li&gt;图灵可识别：接受、拒绝或不停机；图灵可判定：处处停机&lt;/li&gt;
&lt;li&gt;变形&lt;/li&gt;
&lt;li&gt;多带图灵机&lt;/li&gt;
&lt;li&gt;多维图灵机&lt;/li&gt;
&lt;li&gt;非确定性图灵机&lt;/li&gt;
&lt;li&gt;枚举器（图灵可识别&amp;lt;=&amp;gt;存在枚举器枚举）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;形式语言与自动机&#34;&gt;形式语言与自动机&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;线性有界自动机LBA是一种受限的图灵机，不允许其读写头离开包含输入的带子区域&lt;/li&gt;
&lt;li&gt;线性有界自动机等价上下文有关文法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;算法&#34;&gt;算法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;图灵机算法的描述方式&lt;/li&gt;
&lt;li&gt;形式化描述
&lt;ul&gt;
&lt;li&gt;七元组。对图灵机最低层次、最详细程度的描述&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现描述
&lt;ul&gt;
&lt;li&gt;用日常语言描述图灵机的运行(如何存放数据,如何移动读写头)&lt;/li&gt;
&lt;li&gt;不给出状态和转移函数的细节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;高层次描述
&lt;ul&gt;
&lt;li&gt;用日常语言描述算法&lt;/li&gt;
&lt;li&gt;不考虑对读写头和带的管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;通用图灵机&#34;&gt;通用图灵机&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;存放图灵机的编码、存放图灵机带子的内容、存放图灵机的内部状态&lt;/li&gt;
&lt;li&gt;所有图灵机构成的集合是一个可数集&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;可判定语言&#34;&gt;可判定语言&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果存在一个处处停机的图灵机，能够判定给定 的字符串是否属于该语言&lt;/li&gt;
&lt;li&gt;与正则语言相关的可判定性问题&lt;/li&gt;
&lt;li&gt;DFA接受问题：一个有穷自动机是否接受一个串 ✅&lt;/li&gt;
&lt;li&gt;NFA接受问题 ✅&lt;/li&gt;
&lt;li&gt;正则表达式派生问题 ✅&lt;/li&gt;
&lt;li&gt;DFA空性问题：一个DFA是否根本不接受任何串? ✅&lt;/li&gt;
&lt;li&gt;DFA等价性问题：检查两个DFA是否识别同一个语言 ✅
&lt;ul&gt;
&lt;li&gt;正则语言对对称差封闭&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CFG 接受性和空性 ✅&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;不可判定语言&#34;&gt;不可判定语言&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;检查一个图灵机是否接受一个给定的串 ❌ (但是可识别)&lt;/li&gt;
&lt;li&gt;存在不能被任何图灵机识别的语言（语言集合不可数）&lt;/li&gt;
&lt;li&gt;可判定&amp;lt;=&amp;gt;语言和它的补都可识别，可以推出$\bar{A_{TM}}$不可识别&lt;/li&gt;
&lt;li&gt;CFG等价性 ❌&lt;/li&gt;
&lt;li&gt;TM空性 ❌&lt;/li&gt;
&lt;li&gt;修改图灵机，拒绝w以外的所有输入，在w上模拟原图灵机&lt;/li&gt;
&lt;li&gt;然后判定是否为空，得到A_{TM}可判定，矛盾&lt;/li&gt;
&lt;li&gt;等价性（检查两个给定的图灵机是否识别相同的语言）❌&lt;/li&gt;
&lt;li&gt;从空性开始规约&lt;/li&gt;
&lt;li&gt;停机问题HALT_{TM} ❌&lt;/li&gt;
&lt;li&gt;正则性（检查给定图灵机有没有等价的有穷自动机） ❌&lt;/li&gt;
&lt;li&gt;假设能够判定，构造M_{2}在输入x上，接受$0^n1^n$，其他串模拟M&lt;/li&gt;
&lt;li&gt;在输入M_{2}运行R，R接受则接受，拒绝则拒绝&lt;/li&gt;
&lt;li&gt;M_{2}自动接受${0^n1^n|n \ge 0}$中的所有串，如果M_{2}接受w, M_{2}就接受所有其他串&lt;/li&gt;
&lt;li&gt;波斯特对应问题 ❌&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;映射可规约&#34;&gt;映射可规约&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;设$A$和$𝐵$是语言，如果存在可计算函数 $𝑓:Σ^∗ →Σ^∗$，使得对于每个$𝑥$，$𝑥∈𝐴$⟺$𝑓 (𝑥) ∈ 𝐵$, 则称语言$A$映射可归约到语言$𝐵$, 记作$𝐴 ≤_𝑚 𝐵$. 称函数$𝑓$为从$A$到$B$的归约，记作$𝐴 ≤_𝑚 𝐵$ via $𝑓$&lt;/li&gt;
&lt;li&gt;如果$𝐴 ≤_𝑚 𝐵$且$𝐵$是&lt;strong&gt;可判定&lt;/strong&gt;的，则$𝐴$也是可判定的。可判定语言类在映射可归约下封闭（逆否：如果𝐴 ≤𝑚 𝐵且A是不可判定的，则B也 是不可判定的）&lt;/li&gt;
&lt;li&gt;映射归约具有传递性，即: 若$𝐴≤_𝑚𝐵$,且𝐵$≤_𝑚 𝐶$,则$𝐴≤_𝑚 𝐶$&lt;/li&gt;
&lt;li&gt;若$𝐴 ≤_𝑚 𝐵$, 且$𝐵$是图灵&lt;strong&gt;可识别&lt;/strong&gt;的$，则$A$也是图灵可识别的&lt;/li&gt;
&lt;li&gt;为证$𝐵$不是图灵可识别的，可以证明$𝐴 ≤_m \bar{𝐵}$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;时间复杂性&#34;&gt;时间复杂性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度是一个函数：$𝑓(𝑛)$是M在所有长度为$𝑛$的输入上运行时所经过的最大步数&lt;/li&gt;
&lt;li&gt;渐进分析方法、渐进上界&lt;/li&gt;
&lt;li&gt;大O($\le$)和小o($&amp;lt;$)记法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时间复杂性类&lt;/strong&gt;：令$𝑡: 𝑁 → 𝑅^+$是一个函数。 TIME$(𝑡(n))$为由$𝑂 (𝑡(𝑛))$ 时间的图灵机判定的所有语言的集合&lt;/li&gt;
&lt;li&gt;单带图灵机在$𝑜(𝑛\log 𝑛)$时间内判定的语言都是正则语言。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;注意：在==可计算理论==中，丘奇-图灵论题断言：所有合理的计算模型都是等价的，即他们所判定的语言类都是相同的；在==复杂性理论==中，模型的选择影响语言的时间复杂度&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;设$𝑡(𝑛)$是一个函数，$𝑡 (𝑛) ≥ 𝑛$。则每一个$𝑡(𝑛)$时间的多带图灵机都和某一个$𝑂(𝑡^2(𝑛))$ 时间的单带图灵机等价&lt;/li&gt;
&lt;li&gt;设$𝑡(𝑛)$是一个函数，且$𝑡 (𝑛) ≥ 𝑛$。 则每一个$𝑡(𝑛)$时间的非确定型单带图灵机都与某一个$2^{𝑂(𝑡(𝑛))}$ 时间的确定型单带图灵机等价&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;p类与np类&#34;&gt;P类与NP类&lt;/h3&gt;
&lt;h4 id=&#34;p类&#34;&gt;P类&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;能在多项式时间内可判定的语言类&lt;/li&gt;
&lt;li&gt;稳健：对于所有和确定型单带图灵机多项式等价的计算模型来说，P是不变的&lt;/li&gt;
&lt;li&gt;实用：P大致对应于在计算机上实际可解的(tractable)那一类问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;np类&#34;&gt;NP类&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;NP是非确定型单带图灵机在多项式时间内可判定的语言类&lt;/li&gt;
&lt;li&gt;语言𝐴的验证机$𝐴 = {𝑤|对某个字符串𝑐，𝑉接受 𝑤, 𝑐 }$，c为A的成员资格证书或证明&lt;/li&gt;
&lt;li&gt;多项式 时间验证机-&amp;gt;多项式可验证的&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;np完全问题&#34;&gt;NP完全问题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;这些问题中的任意一个如果存在多项式时间算法，那么所有问题都是多项式可解的。&lt;/li&gt;
&lt;li&gt;如果语言B满足下面两个条件，则称为NP 完全的(NP-Complete):
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;$B$属于NP&lt;/li&gt;
&lt;li&gt;NP中的每个$A$都多项式时间可规约到$B$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多项式时间可归约性：若存在多项式时间图灵机$𝑀$， 使得在任何输入$𝑤$上，$𝑀$停机时$𝑓(𝑤)$恰好在带子上，则称函数$𝑓: Σ^∗ → Σ^∗$为多项式时间可计算函数&lt;/li&gt;
&lt;li&gt;若存在多项式时间可计算函数$𝑓: Σ^∗ → Σ^∗$， 对于每一个$𝑤$，有$𝑤∈𝐴$&amp;lt;=&amp;gt;$𝑓(𝑤)∈𝐵$，则$𝐴 ≤_𝑃 𝐵$&lt;/li&gt;
&lt;li&gt;若$𝐴≤_𝑃 𝐵且𝐵∈𝑃$,则$𝐴∈𝑃$&lt;/li&gt;
&lt;li&gt;若$B$是NP完全的，且$B∈P$，则$P=NP$&lt;/li&gt;
&lt;li&gt;若$B$是NP完全的，且$B≤_pC$，$C$属于NP，则$C$是NP完全的&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
  </channel>
</rss>
